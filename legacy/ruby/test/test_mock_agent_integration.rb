# frozen_string_literal: true

require_relative 'test_helper'
require 'snapshot/provider'
require 'mock_agent'
require 'tmpdir'
require 'fileutils'

# Integration tests for MockAgent isolation using snapshot providers
# Tests that multiple agents can run concurrently in isolated workspaces
# without interfering with each other.
class TestMockAgentIsolation < Minitest::Test
  def setup
    @original_repo = Dir.mktmpdir('mock_agent_repo')
    @workspaces = []
    @test_start_time = Time.now

    # Create a realistic test repository
    create_test_repository

    # Choose an appropriate snapshot provider for testing
    @provider = Snapshot.provider_for(@original_repo)
    puts "Using #{@provider.class.name} for isolation testing"
  end

  def teardown
    # Cleanup all workspaces
    @workspaces.each do |workspace|
      @provider.cleanup_workspace(workspace) if @provider.respond_to?(:cleanup_workspace)
      FileUtils.rm_rf(workspace)
    rescue StandardError => e
      puts "Warning: Failed to cleanup workspace #{workspace}: #{e.message}"
    end

    # Cleanup original repo
    FileUtils.rm_rf(@original_repo)
  end

  def test_single_agent_workspace_creation
    workspace = create_isolated_workspace('single_agent')

    # Verify workspace is isolated copy
    assert Dir.exist?(workspace), 'Workspace should exist'
    assert_workspace_isolated_from_original(workspace)

    # Run mock agent
    agent = MockAgent.new(workspace, 'test_single', {
                            min_work_duration: 0.5,
                            max_work_duration: 2.0,
                            create_file_probability: 1.0,
                            modify_file_probability: 0.5
                          })

    result = agent.run_work_session

    assert result[:success], 'Agent should complete successfully'
    assert result[:duration] > 0.4, 'Agent should take some time to work'
    assert result[:activity_count] > 5, 'Agent should perform multiple activities'

    # Verify agent created files in workspace
    generated_files = Dir.glob(File.join(workspace, 'generated_test_single_*'))
    assert generated_files.size.positive?, 'Agent should create some files'

    # Verify original repo is unchanged
    original_files = Dir.glob(File.join(@original_repo, 'generated_*'))
    assert_empty original_files, 'Original repo should not have generated files'
  end

  def test_concurrent_agents_isolation
    num_agents = 4
    agents = []
    threads = []

    # Create isolated workspaces for each agent
    workspaces = (1..num_agents).map { |i| create_isolated_workspace("agent_#{i}") }

    # Launch agents concurrently
    start_time = Time.now

    workspaces.each_with_index do |workspace, i|
      agent_id = "concurrent_#{i + 1}"

      thread = Thread.new do
        agent = MockAgent.new(workspace, agent_id, {
                                min_work_duration: 1.0,
                                max_work_duration: 3.0,
                                create_file_probability: 1.0,
                                modify_file_probability: 0.8,
                                sleep_between_ops: 0.05
                              })

        Thread.current[:agent] = agent
        Thread.current[:result] = agent.run_work_session
      end

      threads << thread
      agents << thread[:agent]
    end

    # Wait for all agents to complete
    threads.each(&:join)
    results = threads.map { |t| t[:result] }
    end_time = Time.now

    # Verify all agents completed successfully
    results.each_with_index do |result, i|
      assert result[:success], "Agent #{i + 1} should complete successfully"
      assert result[:activity_count].positive?, "Agent #{i + 1} should perform activities"
    end

    # Verify isolation - each workspace should have unique generated files
    workspaces.each_with_index do |workspace, i|
      agent_id = "concurrent_#{i + 1}"

      # Check for files generated by this agent
      agent_files = Dir.glob(File.join(workspace, "generated_#{agent_id}_*"))
      assert agent_files.size.positive?, "Agent #{i + 1} should generate files"

      # Check that no other agent's files exist in this workspace
      other_agent_files = workspaces.each_with_index.flat_map do |_other_workspace, j|
        next [] if i == j

        other_agent_id = "concurrent_#{j + 1}"
        Dir.glob(File.join(workspace, "generated_#{other_agent_id}_*"))
      end

      assert_empty other_agent_files, "Agent #{i + 1} workspace should not contain other agents' files"
    end

    # Verify original repository is unchanged
    original_generated = Dir.glob(File.join(@original_repo, 'generated_*'))
    assert_empty original_generated, 'Original repo should remain unchanged'

    # Log performance information
    total_duration = end_time - start_time
    puts "\nConcurrent execution summary:"
    puts "  Agents: #{num_agents}"
    puts "  Total time: #{total_duration.round(2)}s"
    puts "  Average agent time: #{results.map { |r| r[:duration] }.sum / num_agents.round(2)}s"
    puts "  Total activities: #{results.map { |r| r[:activity_count] }.sum}"
  end

  def test_performance_characteristics
    num_workspaces = 5
    creation_times = []
    cleanup_times = []

    # Measure workspace creation performance
    (1..num_workspaces).each do |i|
      start_time = Time.now
      workspace = create_isolated_workspace("perf_#{i}")
      creation_time = Time.now - start_time
      creation_times << creation_time

      # Verify workspace was created properly
      assert Dir.exist?(workspace), "Workspace #{i} should exist"
      assert_workspace_isolated_from_original(workspace)
    end

    # Measure cleanup performance
    @workspaces.each do |workspace|
      start_time = Time.now
      @provider.cleanup_workspace(workspace) if @provider.respond_to?(:cleanup_workspace)
      FileUtils.rm_rf(workspace)
      cleanup_time = Time.now - start_time
      cleanup_times << cleanup_time
    end
    @workspaces.clear

    # Analyze performance
    avg_creation_time = creation_times.sum / creation_times.size
    max_creation_time = creation_times.max
    avg_cleanup_time = cleanup_times.sum / cleanup_times.size
    max_cleanup_time = cleanup_times.max

    puts "\nPerformance characteristics:"
    puts "  Provider: #{@provider.class.name}"
    puts '  Workspace creation:'
    puts "    Average: #{avg_creation_time.round(3)}s"
    puts "    Maximum: #{max_creation_time.round(3)}s"
    puts '  Workspace cleanup:'
    puts "    Average: #{avg_cleanup_time.round(3)}s"
    puts "    Maximum: #{max_cleanup_time.round(3)}s"

    # Performance assertions (these may need adjustment based on provider)
    case @provider
    when Snapshot::ZfsProvider, Snapshot::BtrfsProvider
      # CoW filesystems should be very fast
      assert avg_creation_time < 2.0, "CoW snapshot creation should be fast (avg: #{avg_creation_time}s)"
      assert max_creation_time < 5.0, "CoW snapshot creation should be fast (max: #{max_creation_time}s)"
    when Snapshot::CopyProvider
      # Copy provider will be slower but should still be reasonable for small repos
      assert avg_creation_time < 10.0,
             "Copy provider should complete within reasonable time (avg: #{avg_creation_time}s)"
    end
  end

  def test_filesystem_modification_isolation
    # Create two isolated workspaces
    workspace1 = create_isolated_workspace('modify_1')
    workspace2 = create_isolated_workspace('modify_2')

    # Get initial checksums of shared files
    shared_files = %w[src/hello.rb src/math.rb README.md]
    initial_checksums = {}

    shared_files.each do |file|
      path1 = File.join(workspace1, file)
      path2 = File.join(workspace2, file)

      next unless File.exist?(path1) && File.exist?(path2)

      content1 = File.read(path1)
      content2 = File.read(path2)
      assert_equal content1, content2, 'Initial content should be identical'
      initial_checksums[file] = Digest::MD5.hexdigest(content1)
    end

    # Run agents that modify files
    agents = [
      Thread.new do
        agent = MockAgent.new(workspace1, 'modifier_1', {
                                min_work_duration: 0.5,
                                max_work_duration: 1.5,
                                modify_file_probability: 1.0,
                                create_file_probability: 0.3
                              })
        agent.run_work_session
      end,

      Thread.new do
        agent = MockAgent.new(workspace2, 'modifier_2', {
                                min_work_duration: 0.5,
                                max_work_duration: 1.5,
                                modify_file_probability: 1.0,
                                create_file_probability: 0.3
                              })
        agent.run_work_session
      end
    ]

    # Wait for both agents to complete
    agents.each(&:join)

    # Verify that modifications in one workspace don't affect the other
    shared_files.each do |file|
      path1 = File.join(workspace1, file)
      path2 = File.join(workspace2, file)

      next unless File.exist?(path1) && File.exist?(path2)

      content1 = File.read(path1)
      content2 = File.read(path2)

      # Files might be modified differently by each agent
      checksum1 = Digest::MD5.hexdigest(content1)
      checksum2 = Digest::MD5.hexdigest(content2)

      # At least one should be modified (since modify_file_probability = 1.0)
      # but they should be independent modifications
      next unless checksum1 != initial_checksums[file] || checksum2 != initial_checksums[file]

      # If both were modified, they should likely be different
      # (unless by coincidence they made identical changes)
      puts "File #{file}: workspace1 #{checksum1}, workspace2 #{checksum2}, original #{initial_checksums[file]}"

      # Verify original files are unchanged
      original_path = File.join(@original_repo, file)
      next unless File.exist?(original_path)

      original_content = File.read(original_path)
      original_checksum = Digest::MD5.hexdigest(original_content)
      assert_equal initial_checksums[file], original_checksum, "Original file #{file} should be unchanged"
    end
  end

  def test_large_scale_concurrent_execution
    # Test with more agents to stress test the system
    num_agents = 8
    threads = []

    # Create workspaces
    start_creation = Time.now
    workspaces = (1..num_agents).map do |i|
      create_isolated_workspace("stress_#{i}")
    end
    creation_duration = Time.now - start_creation

    # Launch all agents
    start_execution = Time.now
    (1..num_agents).each do |i|
      thread = Thread.new do
        agent = MockAgent.new(workspaces[i - 1], "stress_#{i}", {
                                min_work_duration: 0.5,
                                max_work_duration: 2.0,
                                create_file_probability: 0.7,
                                modify_file_probability: 0.5,
                                sleep_between_ops: 0.02
                              })

        Thread.current[:result] = agent.run_work_session
      end

      threads << thread
    end

    # Wait for completion
    results = threads.map do |thread|
      thread.join
      thread[:result]
    end
    execution_duration = Time.now - start_execution

    # Verify all completed successfully
    successful_agents = results.count { |r| r[:success] }
    assert_equal num_agents, successful_agents, 'All agents should complete successfully'

    # Check for any interference
    workspaces.each_with_index do |workspace, i|
      agent_id = "stress_#{i + 1}"

      # Count files created by this agent
      Dir.glob(File.join(workspace, "generated_#{agent_id}_*"))

      # Count files created by other agents (should be zero)
      other_files = (1..num_agents).reject { |j| j == i + 1 }.flat_map do |j|
        other_agent_id = "stress_#{j}"
        Dir.glob(File.join(workspace, "generated_#{other_agent_id}_*"))
      end

      assert_empty other_files, "Workspace #{i + 1} should not contain other agents' files"
    end

    # Performance summary
    total_activities = results.map { |r| r[:activity_count] }.sum
    avg_agent_duration = results.map { |r| r[:duration] }.sum / num_agents

    puts "\nLarge scale execution summary:"
    puts "  Agents: #{num_agents}"
    puts "  Workspace creation: #{creation_duration.round(2)}s"
    puts "  Execution time: #{execution_duration.round(2)}s"
    puts "  Average agent duration: #{avg_agent_duration.round(2)}s"
    puts "  Total activities: #{total_activities}"
    puts "  Provider: #{@provider.class.name}"

    # Reasonable performance expectations
    assert creation_duration < 30.0, 'Workspace creation should complete in reasonable time'
    assert execution_duration < 15.0, 'Concurrent execution should complete in reasonable time'
  end

  private

  def create_test_repository
    # Create a realistic repository structure for testing
    FileUtils.mkdir_p(File.join(@original_repo, 'src'))
    FileUtils.mkdir_p(File.join(@original_repo, 'test'))
    FileUtils.mkdir_p(File.join(@original_repo, 'docs'))
    FileUtils.mkdir_p(File.join(@original_repo, 'config'))

    # Add some realistic source files
    File.write(File.join(@original_repo, 'README.md'), <<~README)
      # Test Repository

      This is a test repository for agent isolation testing.

      ## Structure

      - `src/` - Source code
      - `test/` - Test files
      - `docs/` - Documentation
    README

    File.write(File.join(@original_repo, 'src', 'hello.rb'), <<~RUBY)
      # Simple hello world program
      def hello(name = "World")
        puts "Hello, \#{name}!"
      end

      if __FILE__ == $0
        hello
      end
    RUBY

    File.write(File.join(@original_repo, 'src', 'math.rb'), <<~RUBY)
      # Mathematical utilities
      module Math
        def self.add(a, b)
          a + b
        end

        def self.multiply(a, b)
          a * b
        end

        def self.factorial(n)
          return 1 if n <= 1
          n * factorial(n - 1)
        end
      end
    RUBY

    File.write(File.join(@original_repo, 'test', 'test_math.rb'), <<~RUBY)
      require 'minitest/autorun'
      require_relative '../src/math'

      class TestMath < Minitest::Test
        def test_add
          assert_equal 5, Math.add(2, 3)
        end

        def test_multiply
          assert_equal 6, Math.multiply(2, 3)
        end

        def test_factorial
          assert_equal 120, Math.factorial(5)
        end
      end
    RUBY

    File.write(File.join(@original_repo, 'docs', 'api.md'), <<~MARKDOWN)
      # API Documentation

      ## Math Module

      ### Methods

      - `add(a, b)` - Returns sum of a and b
      - `multiply(a, b)` - Returns product of a and b
      - `factorial(n)` - Returns factorial of n
    MARKDOWN

    File.write(File.join(@original_repo, 'config', 'settings.json'), <<~JSON)
      {
        "name": "test-repo",
        "version": "1.0.0",
        "description": "Test repository for agent isolation",
        "author": "agent-harbor test suite"
      }
    JSON

    File.write(File.join(@original_repo, '.gitignore'), <<~GITIGNORE)
      *.log
      .agent_logs/
      generated_*
      tmp/
    GITIGNORE
  end

  def create_isolated_workspace(name)
    workspace = Dir.mktmpdir("workspace_#{name}")
    @workspaces << workspace

    # Use the snapshot provider to create an isolated copy
    @provider.create_workspace(workspace)

    workspace
  end

  def assert_workspace_isolated_from_original(workspace)
    # Verify basic files exist
    assert File.exist?(File.join(workspace, 'README.md')), 'README.md should exist in workspace'
    assert File.exist?(File.join(workspace, 'src', 'hello.rb')), 'src/hello.rb should exist in workspace'

    # Verify content matches original
    original_readme = File.read(File.join(@original_repo, 'README.md'))
    workspace_readme = File.read(File.join(workspace, 'README.md'))
    assert_equal original_readme, workspace_readme, 'README content should match original'

    # Verify they are separate directories
    refute_equal @original_repo, workspace, 'Workspace should be different directory from original'
  end
end
