# Sandboxing Requirements on macOS 14 (Sonoma) – Feasibility and Approaches

**Overview:** We examine each sandboxing requirement for the Blocksense “agent-harbor” project on macOS 14 (Sonoma), and assess whether it can be achieved using Apple’s sandboxing tools. We consider using the deprecated sandbox-exec (Seatbelt profiles) alongside modern macOS security features such as the App Sandbox, System Integrity Protection (SIP), Endpoint Security (ES) framework, Network Extension framework, Virtualization framework, and others. For each requirement, we note if it is **possible**, **partially possible**, or **infeasible** with current APIs, and suggest workarounds or combinations of technologies where applicable (as of late 2025).

## 1\. Prevent Writes Outside Whitelisted Locations (Read-Only FS by Default)

**Goal:** The sandboxed agent should be unable to modify any files except in explicitly whitelisted directories. By default the filesystem should appear read-only, with only specific overlay or cache paths being writable.

**Feasibility:** **Possible (with constraints).** macOS sandboxing can enforce a **deny-by-default** file write policy. Using a custom **Seatbelt** profile (via sandbox-exec or the underlying libsandbox API), one can deny all file write operations globally and then allow writes only to specific whitelisted paths[\[1\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=%60sandbox,with%20a%20profile%20like). For example, a profile could contain rules such as:

(deny file-write\*) ; deny all writes by default
(allow file-write\* (subpath "/path/to/allowed/cache")) ; allow writes only under specific directory

This approach was used by AI agent tools that run shell commands on macOS – e.g. OpenAI’s Codex CLI and Google’s Gemini CLI used sandbox-exec with a profile allowing no file writes except perhaps to /dev/null[\[2\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=To%20alleviate%20the%20risk%20of,exec%20%60command%20on%20macOS). Similarly, the **Nix** package manager’s sandbox on macOS switches to using Apple’s sandbox API (libsandbox) to restrict build processes from writing outside the Nix store or designated temp dirs[\[3\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=The%20fix%20for%20this%20issue,exec%60%20to%20%60libsandbox).

**Details and Tools:** On Sonoma, **App Sandbox** (the macOS application sandbox) also gives a form of write restriction: a sandboxed app by default can only write to its own container directory (\~/Library/Containers/\<app-id\>). However, customizing App Sandbox entitlements for arbitrary CLI tools is not trivial – it requires code signing with specific entitlements and is primarily designed for App Store apps[\[4\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=The%20new%20approach%20is%20the,an%20app%20to%20do%20so). In contrast, using a custom Seatbelt profile via sandbox_init/sandbox-exec gives fine-grained control to whitelist specific writable paths. Apple has marked sandbox-exec as deprecated, but it still works on macOS 14 and is widely used internally (Apple’s “Seatbelt” sandbox underpins App Sandbox itself)[\[5\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now)[\[6\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=app%20startup,an%20app%20to%20do%20so).

Other mechanisms: **System Integrity Protection (SIP)** already makes certain parts of the filesystem read-only (e.g. system OS files), but SIP doesn’t restrict writes to user-space locations. **Chroot jails** on macOS are not a secure solution (they require root and can be escaped by root processes), so the recommended approach is using the sandbox profile. Optionally, one can create “writable overlay” mounts manually (for example, using a read-only disk image for most files and a writable layer for changes), but macOS doesn’t provide an easy union/overlay filesystem to non-root users. A more heavyweight but effective solution is to use the **Virtualization framework** to run the agent in a lightweight VM – the VM’s disk can be configured as mostly read-only with a writable overlay disk for changes, thereby completely isolating file modifications to the VM. This offers strong guarantees but at significant complexity and some performance cost.

**Conclusion:** Enforcing a read-only filesystem with specific writable directories is **possible** using Seatbelt sandbox profiles (still functional on Sonoma[\[7\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=As%20a%20user%2C%20sandboxing%20profiles,the%20newer%20App%20Sandbox%20feature)) or by running the agent under a separate restricted user account with only certain directories owned by that user (an approach used by tools like _Alcoholless_[\[8\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=How%20it%20works)). The latter (separate user) approach, combined with file system permissions, can confine where the agent can write. For strict guarantees and easier “overlay FS” semantics, a VM-based sandbox could be used (assigning a limited disk image to the agent). In summary, requirement \#1 can be met on macOS 14 by using the sandbox policy language to **deny file-write** except on whitelisted paths[\[1\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=%60sandbox,with%20a%20profile%20like), possibly supplemented by running the agent as an unprivileged user to limit its file ownership rights[\[9\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20just%20utilizes%201990s%E2%80%99%20commands,are%20not%20recognized%20by%20POSIX).

## 2\. Dynamic Read Allowlist Enforcement (Interactive Read Access Approval)

**Goal:** If the agent attempts to read files outside an approved allowlist, those access attempts should be blocked _until_ an interactive approval is granted by a supervising user/process. In other words, file reads outside certain directories should trigger a permission prompt or request to a supervisor.

**Feasibility:** **Partially possible.** Out-of-the-box, the macOS sandbox profile is static – it can allow or deny specific file read paths, but it cannot _prompt_ the user for approval dynamically. However, macOS **Endpoint Security (ES) Framework** can be leveraged to achieve this behavior. The ES framework allows a security service (running with special privileges) to subscribe to file access events and even **block/allow** them in real time[\[10\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,to%20how%20antivirus%20software%20works). Specifically, ES provides _authorization_ events like ES_EVENT_TYPE_AUTH_OPEN (file open) which the ES client (supervisor) can intercept. The ES client can decide to allow or deny the open, and could pause the agent’s thread until a decision is made. In practice, the ES callback could signal an external supervisor process which in turn asks the user for consent (e.g. via a GUI prompt), then instructs ES to allow or deny the file read. This **interactive policy approval** is conceptually achievable: Apple designed ES as a replacement for legacy kernel auth hooks, enabling tools “similar to how antivirus software works” that can **prevent file accesses** unless certain conditions are met[\[10\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,to%20how%20antivirus%20software%20works).

As evidence of feasibility, Sonoma’s own security enhancements implement a form of interactive file access prompting for App Sandbox containers: if a sandboxed app tries to access another app’s container directory, the system presents a user dialog “\<App\> would like to access data from other apps” and blocks access unless allowed[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing)[\[12\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=Sandbox%20containers%20on%20Sonoma%20seemed,apps%2C%20even%20from%20Terminal%20app). This shows macOS 14 can block a file read and wait for user approval at the OS level in certain scenarios. We can mimic this behavior for our custom allowlist by using ES or a similar mechanism in a supervisor daemon.

**Implementation considerations:** Using the Endpoint Security framework requires creating a **System Extension** or daemon with the com.apple.developer.endpoint-security.client entitlement (granted by Apple). The supervisor would run with elevated privileges (though not necessarily root – it runs as a system-extended privileged process) and listen for the agent’s file-access attempts. This approach is complex (requires maintaining a responsive ES client that won’t stall the entire system if user delays a decision too long), and there may be performance implications if many file reads get queued for approval. It is also possible to implement a simpler scheme if full interactivity isn’t needed: e.g. run the agent in a very restrictive sandbox that by default denies all file reads except a base whitelist – any attempt to open a disallowed path will just fail (logged as a sandbox violation). The supervisor could then decide (based on those logs or an IPC request from the agent) to relaunch the agent with a relaxed profile or inject a temporary rule. However, dynamically altering a running sandbox profile is **not** supported directly; one would typically have to predefine a superset of rules or restart the sandbox with new rules.

**Conclusion:** True interactive, on-the-fly approval of file reads is **partially possible** on macOS. It’s not built into sandbox-exec or App Sandbox, but by leveraging the Endpoint Security API’s ability to **block pending file operations**[\[13\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=execute%20from%20the%20Endpoint%20Security,to%20how%20antivirus%20software%20works), a supervisor can implement a custom prompt workflow. Apple’s own behavior in Sonoma for cross-app container access demonstrates the concept[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing). Thus, requirement \#2 can be met with a custom ES-based solution (complex but feasible), whereas purely using sandbox-exec alone would not provide interactive prompts (only blanket allow or deny).

## 3\. Process Isolation (No Visibility or Interference with Host Processes)

**Goal:** The sandboxed process should not be able to see or affect processes outside its sandbox – it shouldn’t list system processes or interfere with other user/host processes (no sending signals, ptrace, etc. to outside processes).

**Feasibility:** **Mostly possible.** macOS does not have a native “PID namespace” to completely hide other processes (unlike some OS-level virtualization on Linux), but several layers of restriction achieve this in practice:

- **App Sandbox/Seatbelt restrictions:** A properly sandboxed process is **prevented from interacting with other processes via system APIs.** For example, in the default Application Sandbox profile (application.sb), there are rules that block obtaining task ports for other processes unless an entitlement is present. By default, sandboxed apps cannot call sensitive APIs like task_for_pid() on other processes (used for attaching debuggers) – these calls will fail unless the process has the special debugging entitlement (which it won’t in production)[\[14\]](https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html#:~:text=Attaching%20a%20debugger%20to%20the,is%20not%20enabled%20by%20default). They also cannot send Apple events or XPC messages to other apps unless explicitly allowed. Thus, **interference** (such as sending signals or injecting code) is denied by the sandbox.

- **Process visibility:** Even outside the sandbox, macOS limits some cross-process visibility. A non-root user can list processes via commands like ps, but cannot inspect details of others’ processes without privilege. Running the agent under a separate, dedicated user account is an extra layer: processes owned by a different user cannot be killed or debugged by the agent process without root privileges (the OS will return EPERM for attempts to signal or trace another user’s processes). The sandbox can further deny access to any interfaces that enumerate processes. For instance, the Seatbelt profile could deny access to system interfaces like the Mach special ports or sysctl calls that retrieve process lists. (Apple’s sandbox profiles for system services often include such restrictions.) In practice, if an agent tries to enumerate all processes (e.g. using sysctl(KERN_PROC) or similar), a stringent sandbox profile can be crafted to deny those calls – though Apple doesn’t publicly document every rule, the sandbox can control “process\*” operations as well.

- **Full isolation via virtualization:** To absolutely ensure the agent cannot see host processes, the strongest approach is to run it in a **Virtualization.framework VM** or a lightweight container. In a VM (even a minimal Linux VM), the agent’s view of “the system” is limited to that VM – it will only see processes running inside the VM. This achieves true PID namespace isolation. The downside is complexity and resource overhead. Apple’s Virtualization framework on Sonoma allows running a Linux or macOS VM in user space (with proper entitlements) – inside that, the agent would be effectively isolated from the host OS processes entirely.

**Conclusion:** Preventing a sandboxed process from _interfering_ with host processes is **possible** with macOS sandboxing – by default it will not be able to send signals or attach to others outside the sandbox (lack of privileges and sandbox denial). Preventing it from even _seeing_ other processes’ existence is trickier: a determined process might list some system process names via ps unless additional measures are in place. Using a separate user ID for the agent and a strict seatbelt profile provides a strong approximation of process isolation. For absolute guarantees (no visibility at all), a VM or perhaps running the agent in a separate login session/space would be needed. In summary, requirement \#3 can be mostly fulfilled by the App Sandbox/Seatbelt (for interference) and partially by system policy (for visibility). It’s **possible** to meet the spirit of this requirement with existing tools, especially if layering a VM or separate user context for defense-in-depth.

## 4\. Network Isolation (Restricted Egress, DNS and IP/Port Whitelisting)

**Goal:** The agent’s network access should be heavily restricted. By default it should have no outbound network connectivity, unless explicitly allowed for certain DNS domains, IPs, or ports (whitelist). The design might include blocking all egress and then interactively or config-based enabling access to specific services.

**Feasibility:** **Partially possible with built-in sandbox, fully possible with additional frameworks.** The macOS sandbox profile language can **completely deny network access** or restrict it to only loopback, but it cannot filter specific hostnames or IP ranges. Seatbelt rules like (deny network\*) will block all network I/O[\[15\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,data%20%28regex%20%22%5E%2FUsers%2F%5B%5E%2F%5D%2B%2F%28Documents%7CPictures%7CDesktop), and there is an option to allow only loopback traffic (allow network-outbound (remote ip "localhost:\*")) in profiles[\[16\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%28allow%20default%29%20%28deny%20network,outbound%20%28remote%20ip%20%2210.0.1.1%3A443). However, as of current macOS, the sandbox does **not support granular host/port filtering** – attempts to specify a particular IP or port in a sandbox rule result in an error (“host must be \* or localhost in network address”)[\[17\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%28deny%20network,outbound%20%28remote%20ip%20%2210.0.1.1%3A443). This limitation is documented via reverse-engineering: _“\[The sandbox\] has no support for IP filtering; it must be localhost or_ ”\*[\[18\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=The%20man%20page%20for%20%60sandbox,though%20is%20not%20good%20news). In short, the Seatbelt sandbox can turn off networking entirely or allow all, but cannot itself enforce a fine-grained whitelist of external hosts[\[19\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%3E%20host%20must%20be%20,or%20localhost%20in%20network%20address).

**Solutions:** \- For static restrictions, one approach is to combine a sandbox that _denies all network_ with a user-space proxy. For example, previous developers have worked around the lack of host filtering by proxying desired domains through localhost: one can allow only loopback in the sandbox and run a local proxy server that the agent can connect to[\[20\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=more%20information%29). The proxy then controls external access. This is cumbersome but was suggested (e.g. running a local devpi or mitmproxy so that the sandboxed process accesses localhost:port which is permitted, and the proxy relays to the real external resource)[\[20\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=more%20information%29).

- The modern and robust method on macOS is to use the **Network Extension** framework for a firewall-like filter. Apple’s Network Extension (NE) API includes **Content Filter** providers and **DNS Proxy/Filter** providers that can programmatically allow or block traffic on a per-host or per-port basis. For example, one could implement an NE content filter that only permits connections to a predefined set of IPs/domains, dropping all others. The NE framework operates at the system level (requiring a System Extension with the appropriate NE entitlement). A **NEFilterControlProvider** can even make real-time decisions for new network flows, possibly in concert with a supervisor app. This would achieve the dynamic whitelist requirement, though it’s a significant development effort (essentially writing a custom firewall). Alternatively, a simpler approach could be using the system’s packet filter (PF) by adding rules to block all outbound traffic from the agent’s process/user except to certain addresses – but modifying PF requires root privileges and is not user-friendly.

- The **Endpoint Security framework** also has event types for network operations (e.g. ES_EVENT_TYPE_AUTH_SOCKET_CONNECT for outbound connections)[\[21\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,remount). In theory, an ES client could intercept each connect() call and decide to allow or deny based on destination address. Like with file reads, this would allow interactive approval or strict whitelisting by policy. ES is lower-level (it deals with sockets rather than higher-level DNS domain names easily), so implementing domain-based filtering may require doing reverse DNS lookups or intercepting DNS queries as well (which NE’s DNS proxy would handle more directly).

**DNS considerations:** The sandbox can block all DNS by denying network altogether (since DNS queries are network packets). If we want to allow DNS to certain servers or implement a custom DNS resolution policy, the **NEDNSProxy** portion of Network Extension can intercept DNS queries from the agent and filter or forward them. This can be combined with a content filter to restrict actual traffic. Without NE, one could also set the agent’s environment to use a stub resolver that queries a local DNS proxy under our control.

**Conclusion:** Achieving strict network egress control is **possible**, but not by sandbox-exec alone beyond an all-or-nothing scope. You can certainly **deny all network access** to the sandboxed agent easily (that’s a common profile rule[\[15\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,data%20%28regex%20%22%5E%2FUsers%2F%5B%5E%2F%5D%2B%2F%28Documents%7CPictures%7CDesktop)). To then allow _only specific hosts/ports_, you must introduce an external filtering mechanism. The most appropriate modern solution is writing a Network Extension (with Apple’s blessing via entitlements) to whitelist certain traffic. This fulfills the requirement of domain/IP/port control robustly. If implementing a full NE extension is infeasible, a simpler combination might be: sandbox deny all network \+ custom user-mode proxy for allowed destinations, which the user/supervisor controls. In summary, fine-grained network isolation is **partially possible** with built-in sandbox features (coarse toggles), but fully achievable using Apple’s network filtering APIs (at the cost of complexity)[\[18\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=The%20man%20page%20for%20%60sandbox,though%20is%20not%20good%20news)[\[22\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=Filtering%20network%20access%20to%20specific,normally%20blocked%2Fallowed%3F%20Not%20sure%20though).

## 5\. Debugging Within the Sandbox (Allow ptrace/LLDB _inside_, but no outside access)

**Goal:** The agent (or user of the agent) should be able to debug processes _within_ the sandbox – e.g. attach a debugger (LLDB) to a program the agent launched, for introspection – but the sandbox should prevent debugging or attaching to _outside_ processes on the host.

**Feasibility:** **Possible with careful configuration.** By default, macOS sandboxing **disables debugger and tracing capabilities** for security. A sandboxed app cannot be debugged or debug others unless certain exceptions are made. For instance, Apple’s App Sandbox requires the code-signing entitlement com.apple.security.get-task-allow to let a debugger attach during development – without it, even the app’s own process can’t be attached by LLDB[\[14\]](https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html#:~:text=Attaching%20a%20debugger%20to%20the,is%20not%20enabled%20by%20default). So, out-of-the-box, a locked-down sandbox forbids ptrace/task_for_pid both inbound and outbound.

To allow _internal_ debugging, we have a few options:

- **Entitlements for development:** If we are controlling this environment, we could code sign the agent and its child processes with the get-task-allow entitlement during development runs. That would permit LLDB (running as the same user outside the sandbox) to attach to the sandboxed process for debugging. However, in a production setting that entitlement is removed for security – so this is mainly a dev-time convenience.

- **Sandbox rules adjustments:** The Seatbelt profile language likely has a rule for process\* operations. For example, one could allow ptrace/inspect on processes that are within the same sandbox or same user. This is not officially documented, but on macOS if the agent launches child processes, those children inherit the sandbox. The agent could be allowed to debug those children if the sandbox profile doesn’t explicitly deny process-inspect for child PIDs. If we run everything under the same user and within the same sandbox session, standard Unix permissions apply: a process can ptrace another process with the same UID if not blocked by sandbox and if code-signed appropriately (hardened runtime by default blocks it unless get-task-allow or running under a debugger already). In a custom sandbox profile, we could _omit_ restrictions on tracing child processes. (Apple’s default App Sandbox _does_ block it unless you have the entitlement, but a custom profile could in theory allow it since this is our own security policy to configure.)

- **Separate user & OS barriers:** If using the separate user approach (like Alcoholless), the agent and any processes it launches run as a distinct user (say “sandboxuser”). That user’s processes can debug each other freely (subject to code signing as mentioned). They will not be able to attach to processes of other users (the host’s normal user processes), because the kernel enforces that you cannot trace a process you don’t own. So simply by user separation, we largely achieve the requirement: the agent can run LLDB on a program it spawned (same UID), but if it tries to attach to some other owner’s process, it gets permission denied. This aligns well with using su to drop the agent to a limited user.

- **Virtualization approach:** If the sandbox is a full VM, then inside that VM the agent has full control of its environment and can run debugging tools on local processes, but of course it cannot see or touch the host’s processes at all. This cleanly satisfies the isolation at the highest level (with the cost of running a VM).

**Conclusion:** It is **possible** to support debugging within the sandbox, but it requires consciously **allowing ptrace** for the sandbox’s own processes while **denying any access to external ones**. By default, a strict sandbox would deny ptrace/task_for_pid to anything (to prevent sandbox escape via attaching to unsandboxed processes). We can relax this for internal use. For example, one might run the agent’s tasks with a special code signature that enables debugging (for internal use only), or simply perform debugging in a development configuration where the sandbox is not at its highest lockdown. Using a separate user or VM inherently ensures that outside processes are off-limits (the OS won’t permit cross-user or cross-VM attachment). Thus, requirement \#5 is **achievable**. We must ensure any sandbox profile includes allowances for debugging tools (or run those tools outside the sandbox with temporary permissions). Notably, we should avoid giving the sandboxed process any broad entitlement that would let it debug arbitrary processes – keep it limited to same-user/same-sandbox processes. In practice, this might mean the supervisor temporarily grants com.apple.security.get-task-allow to binaries that need debugging and all such debugging happens under the auspices of our controlled environment[\[14\]](https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html#:~:text=Attaching%20a%20debugger%20to%20the,is%20not%20enabled%20by%20default).

## 6\. CPU/Memory/PID/I/O Resource Limits

**Goal:** Impose limits on the sandboxed agent’s resource usage – e.g. cap CPU time or utilization, limit memory consumption, restrict number of spawned processes, and perhaps throttle I/O operations – to prevent runaway consumption or abuse.

**Feasibility:** **Partially possible.** Unlike Linux (which has cgroups for fine-grained resource control), macOS has more rudimentary controls:

- **CPU limits:** macOS supports POSIX setrlimit(RLIMIT*CPU) to set a maximum CPU time (in seconds) for a process. If the process exceeds that total CPU time, it will be sent a SIGXCPU (and ultimately killed). This is a blunt instrument but can prevent a process from using CPU indefinitely. There isn’t a built-in way to \_throttle* CPU usage to e.g. 20% – one can nice the process to reduce priority, but not an absolute cap. The launchd daemon does have a property list key for CPU limits (JetSam-style CPU Monitor), but that is primarily used for killing apps that use too much CPU for too long (similar to RLIMIT_CPU). We can consider the CPU limit **possible** at least to set a cut-off or monitor via an external watchdog.

- **Memory limits:** macOS’s setrlimit for virtual address size or RSS (RLIMIT_AS and RLIMIT_RSS) historically is not reliably enforced. In fact, as of 2018, macOS does **not enforce** RLIMIT_AS (address space limit) or RLIMIT_DATA – setting them has no effect on actual memory allocation success[\[23\]](https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit#:~:text=1). This means we cannot count on setrlimit to cap memory usage. A possible workaround is to run the agent in a constrained environment like a VM: when using the Virtualization framework, you can assign a fixed amount of RAM to the virtual machine. The guest OS will be unable to use more than that, effectively capping memory for everything in that sandbox. For a lighter weight approach, one could periodically check the process’s memory and kill it if it exceeds a threshold (a crude approach via the supervisor). macOS 14 doesn’t offer user-accessible memory limits per process otherwise (except perhaps Jetsam on iOS, but that’s not exposed on macOS).

- **Process count limits:** We could impose a limit on number of processes via setrlimit(RLIMIT_NPROC) for the user. On macOS, RLIMIT_NPROC can limit the number of processes a given UID can have. If the agent runs under a separate user account, we could set this limit low (via launchd or prior to dropping privileges). That would prevent fork-bombs. This is a standard Unix limit and should work on macOS. So yes, we can cap the number of processes in the sandbox user context – **possible**.

- **I/O (disk) limits:** macOS doesn’t have a straightforward equivalent to Linux’s IO cgroups or disk quotas that can be set per process. If the sandbox uses a separate disk image or volume (as might be the case in a VM or if using a separate user home directory on APFS), one could set an APFS quota on that volume to limit total disk usage. Throttling disk _throughput_ or IOPS is not readily achievable in user space. We may rely on the fact that heavy I/O by the agent will mostly affect only its own allowed paths (which could be on slower external storage or a disk image). There is no public API to say “limit this process to X MB/s of disk”. So this aspect is **infeasible** to enforce precisely on macOS. At best, an I/O monitor could detect if the agent is causing performance issues and intervene.

In addition, **App Sandbox** itself does not provide resource control – it’s about permission, not quotas. **Endpoint Security** can monitor certain events (file writes, execs) to possibly count them but not throttle them. **DTrace** or Instruments could theoretically watch resource usage, but not enforce limits without custom actions.

**Conclusion:** Resource limiting on macOS is **fragmented**: some limits can be set (CPU time and number of processes via rlimits are possible; open file descriptors can also be limited with RLIMIT_NOFILE). Memory limiting is essentially **not supported** via rlimit (Apple doesn’t honor RLIMIT_AS for enforcement[\[23\]](https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit#:~:text=1)). The most robust containment here is to use a Virtualization sandbox – give the VM 1 CPU core and 1GB RAM, for example, and that implicitly caps what the agent can use. If a full VM is too heavy, one can partially achieve this requirement by using existing Unix mechanisms: e.g., before launching the agent, call setrlimit for CPU and NPROC, perhaps use ulimit \-f to limit file sizes it can create, etc. Also consider using **launchd** to manage the agent – launchd has options for resource limits in job plists (such as HardResourceLimits). Overall, requirement \#6 is **partially possible** on macOS: CPU and process limits yes, memory and I/O throttling not easily without a VM or external monitoring.

## 7\. Secure Nested Containers/VMs (Running Docker or VMs _inside_ the Sandbox)

**Goal:** The sandboxed agent may itself need to run Docker containers or even launch nested virtual machines (for example, an agent might try to start a Docker container for a task). We need to know if this is possible within our sandbox, and safe.

**Feasibility:** **Partially possible, but with significant constraints.** Running _nested_ virtualization or containers inside a restricted sandbox is complex:

- **Docker:** Docker on macOS (Docker Desktop) runs containers inside a hidden Linux VM. To use Docker, the agent would typically communicate with the Docker daemon via a UNIX socket (/var/run/docker.sock). In a locked-down sandbox, access to that socket can be denied or allowed selectively. If we **allow** it, then effectively the agent could ask Docker to run containers on the host. This is dangerous because those containers, while isolated from the host OS, are not necessarily constrained from the agent’s perspective – the agent could potentially abuse Docker to escape restrictions (for instance, mounting the host filesystem via Docker if not prevented). Generally, giving a sandboxed process access to Docker breaks the isolation model (Docker becomes a pathway out). Unless we strictly control what Docker commands can do (which is hard), it’s not advisable to let an untrusted sandbox spawn arbitrary Docker containers on the host.

- **Virtualization.framework inside sandbox:** Apple’s Virtualization framework _could_ allow the agent to start a lightweight VM (e.g., a Linux VM) from within the sandbox. However, using the Virtualization APIs requires the calling process to have the **com.apple.security.virtualization** entitlement[\[24\]](https://developer.apple.com/documentation/virtualization/adding-the-virtualization-entitlement-to-your-project#:~:text=Adding%20the%20Virtualization%20Entitlement%20to,this%20entitlement%20to%20your%20app). In our design, the agent process itself would not be entitled (we don’t want to grant it broad rights). The supervisor could be entitled and could launch VMs on behalf of the agent, but that moves the execution outside the agent’s sandbox context (the VM would be managed by the supervisor). If the agent is running in a seatbelt sandbox, it likely won’t be allowed to call hypervisor functions itself (those might be blocked as privileged operations).

Additionally, **nested VMs** (a VM inside our VM) are generally not supported or at least not efficient on Apple Silicon. If we already used a VM as our primary sandbox, running another VM inside it may not work (Apple’s hypervisor does not currently support nested virtualization in any fully functional way, especially on Apple Silicon).

- **Attainable approach:** If nested container/VM capability is truly needed, one approach is for the sandbox to _simulate_ it. For example, we could allow the agent to run a container but actually intercept that request and run the container in a controlled way outside the sandbox, presenting results back. This requires custom integration (not trivial). Alternatively, as mentioned, run the entire agent in a VM – inside that VM the agent can freely use Docker or even QEMU if it wants, and it’s all contained in the outer VM sandbox. This is heavy but keeps the host safe.

It’s worth noting that some security sandboxes choose _not_ to allow any form of further virtualization by the confined process, to reduce complexity. In our case, to be safe, we might _deny access to hypervisor APIs_ in the sandbox profile (prevent loading the hv_vmm or communicating with Docker’s socket). That would make nested virtualization **infeasible** for the agent – which might be acceptable if not needed.

However, if the requirement is to **allow** nested containers, then the design must carefully allow those actions without compromising security. For instance, one could allow the agent to use Docker but only with certain safe base images and no host mounts. Implementing that would likely rely on the supervisor mediating Docker commands.

**Conclusion:** Running Docker or VMs _inside_ the sandbox is **challenging**. It is _possible_ only if the sandbox is configured to permit it, and even then it should likely be orchestrated by the supervisor. Out of the box, a strict sandbox would block the necessary privileges (no access to /dev/hypervisor or Docker daemon). Given that Apple’s Virtualization framework requires entitlements and user approvals (e.g., running macOS guests requires user to accept a EULA manually, as noted by Akihiro Suda[\[25\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20could%20even%20harden%20security,iCloud%2C%20set%20up%20SSH%2C%20etc)), an unprivileged sandbox can’t spontaneously launch new VMs on Sonoma. So, if nested container/VM support is required, the cleanest solution is to run the entire agent in a VM where it has the illusion of full control and can then run Docker inside that VM if needed (with no risk to the host). This makes the requirement **partially possible** – possible _if_ you’re willing to embed one sandbox inside another, but not by default through simple seatbelt rules.

## 8\. Supervisor Outside the Sandbox (Policy Enforcement Outside)

**Goal:** Keep a “supervisor” process outside the sandbox which manages policies, monitors the sandboxed agent, and controls what it can do (e.g., approving requests as mentioned).

**Feasibility:** **Possible (and recommended).** This architecture is actually aligned with Apple’s model for system extensions: a privileged **controller** (outside sandbox) enforces rules on a monitored **client** (inside sandbox). In our case, the supervisor could be a normal daemon or application with elevated rights (e.g., having Endpoint Security and Network Extension entitlements). It would not be sandboxed (or less restricted), so it can perform tasks like showing UI prompts, altering policies, or even killing the sandboxed agent if needed.

There is no technical barrier to having a supervisor outside – it’s the natural design. The supervisor can use interprocess communication (IPC) to talk to the sandboxed agent. For instance, the agent could make an XPC call to request a file access, or more transparently, the supervisor can intercept events via ES/NE as discussed. The key is to ensure the sandbox rules allow whatever minimal communication is needed between the agent and supervisor. This might be a dedicated communication channel: e.g., a Unix domain socket at a known path that we allow the agent to write to, or an XPC service the agent can reach. We would incorporate that into the sandbox profile (whitelisting that socket or Mach service name).

Because the requirement explicitly calls for a supervisor outside managing policy (\#9 expands on interactive approval), we treat this as not only possible but **essential**. It also aligns with the **principle of least privilege**: the supervisor can run with the rights needed to enforce security (maybe running under an administrator account or as a system extension), while the agent runs with minimal rights. Apple’s documentation encourages such designs (e.g., a privileged helper tool managing a sandboxed app’s requests).

**Conclusion:** Requirement \#8 is **fully possible**. We will run a controller outside the sandbox. This process will have the ability to adjust policies (perhaps by loading new sandbox profiles for subsequent runs, or by instructing system frameworks to allow certain actions for the sandboxed process). This supervisor can also act as a “broker” for any operation the sandbox can’t do on its own (similar to how App Sandbox apps use XPC helpers for privileged operations). There are no Sonoma-specific issues here beyond obtaining the necessary permissions for the supervisor (ES or NE entitlements, etc.).

## 9\. Interactive Policy Approval (Requests Sent to Supervisor for OK/Reject)

**Goal:** The sandbox should not just silently block forbidden operations – ideally, it should ask the user or an admin at runtime to approve certain actions (file access, network access, etc.), with the supervisor mediating these prompts.

**Feasibility:** **Possible (with custom implementation).** Apple’s security frameworks support this pattern, but it’s not automatic – we have to build it. For example, the **Endpoint Security** authorization events can be used for this purpose: when the agent tries to open a file that’s outside its allowlist, our ES extension gets an AUTH*OPEN event. The extension can \_pause* the operation and send a message to the supervisor UI. The user could then click “Allow” or “Deny”, and the extension responds accordingly to either let the file open or block it. This is exactly how interactive approvals can be done. It is analogous to how personal firewall or antivirus software might prompt on first access to something.

Likewise, for network, a **Network Extension content filter** can be configured in _silent mode_ where it asks a control app for a decision on a new connection. The NEFilterControlProvider could pop up a question like “Agent X wants to connect to 1.2.3.4:80 – allow?” and then enforce the decision.

Apple doesn’t provide a turnkey “ask the user” mechanism for arbitrary resources, except in specific cases (like the system privacy prompts for camera, microphone, or in Sonoma, one app accessing another app’s container triggers a system prompt[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing)). Those system prompts are not extensible to our custom policy – we have to implement it ourselves.

We have real-world precedent: in Sonoma, if a Terminal app tries to read a sandboxed app’s data, the system will _interactively ask_ the user for permission[\[12\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=Sandbox%20containers%20on%20Sonoma%20seemed,apps%2C%20even%20from%20Terminal%20app). After denial, the operation is blocked[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing). This is essentially what we want, but for a broader set of paths and actions.

**Implementation details:** We will need to ensure the sandboxed agent can communicate the nature of its request to the supervisor (either implicitly via ES events or explicitly via an RPC). The supervisor should maintain a UI (could be a menubar app or daemon that can show alerts) to prompt the user. One challenge is timing – if the agent is waiting on a file read, it will block until a decision. We must handle the possibility that the user doesn’t respond; typically, we’d implement a reasonable timeout or default-deny after X seconds.

Another consideration is to avoid _too many_ prompts (could be annoying or lead the user to blindly allow). We might incorporate a caching (“remember this decision”) similar to how firewalls do. These are design issues outside the scope of OS capability – the OS _does_ allow this interactive control as described.

**Conclusion:** This requirement is essentially the UI/policy layer on top of \#2 and \#4. It is **possible** on macOS 14, but requires building a custom policy engine. Both Endpoint Security and Network Extension frameworks are designed with the idea that a user-mode agent will make allow/deny decisions for events[\[13\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=execute%20from%20the%20Endpoint%20Security,to%20how%20antivirus%20software%20works) – those decisions can certainly involve interactive user approval. Nothing in Sonoma prevents this; it actually aligns with Apple’s direction of moving security logic to user-space daemons that the user can control. So requirement \#9 can be satisfied by our supervisor process acting as an interactive policy broker.

## 10\. No Publicly Known Sandbox Escapes; Defense-in-Depth

**Goal:** The sandbox solution should have no **known** escape vulnerabilities and employ multiple layers of defense so that even if one layer is breached, others prevent a full compromise (defense in depth).

**Feasibility:** **Partially possible.** We can design for defense-in-depth by combining several sandboxing techniques: e.g., run the agent in a locked-down Seatbelt sandbox _and_ under a separate user account _and_ with minimal privileges, possibly inside a VM. The idea is that an attacker would need to defeat multiple isolation layers to break out. macOS allows stacking these measures – for instance, Apple’s own sandboxed apps run with both App Sandbox _and_ SIP protecting the system, and cannot access certain device files, etc.

However, we must be realistic: **no sandbox is 100% escape-proof**, especially over time. There have been multiple macOS sandbox escapes reported in recent years. For example, in April 2024, Microsoft discovered a vulnerability (CVE-2025-31191) where a malicious macro could exploit security-scoped bookmarks to escape the App Sandbox[\[26\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=In%20April%202024%2C%20Microsoft%20uncovered,target%20the%20Microsoft%20Office%20app)[\[27\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=,updates%20as%20soon%20as%20possible). Apple patched this in macOS updates by 2025\. Similarly, other sandbox escape bugs (CVE-2022-26696, CVE-2025-31258, etc.) have been found and fixed[\[28\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=Since%202022%2C%20Apple%20has%20made,of%20malicious%20Office%20macros%20is). So “no _publicly known_ escapes” is a moving target – as of late 2025, we should ensure the system is fully updated to incorporate Apple’s fixes for known sandbox flaws[\[27\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=,updates%20as%20soon%20as%20possible). We can’t guarantee a new 0-day doesn’t exist, but we can aim to use the most robust configuration available.

**Defense-in-depth measures:**

- Use **multiple containment mechanisms** simultaneously. For instance, even if the Seatbelt sandbox is compromised by some exploit, the agent is still a low-privilege user with no root rights (and SIP prevents tampering with system files). If the agent somehow breaks out of the sandbox to normal user privileges, it still cannot write to sensitive system locations (SIP) and cannot escalate to root without another flaw. If we add a VM boundary, an escape from the inner sandbox just lands in the VM’s OS, which would then need a VM escape to reach the macOS host.

- **Minimize attack surface** in the sandbox profile: do not allow any more permissions than absolutely necessary. Many known escapes exploit overly broad allowances or macOS-specific API loopholes (like the bookmark API). If we don’t allow those APIs or resources in the sandbox, the exploit might not work. For example, if we deny all AppleEvents and remove access to user’s home except what’s needed, we cut off a lot of potential avenues.

- Keep the sandboxed components **unprivileged**. This is covered by requirement \#11 (no root). If the agent isn’t running as root, many potential escapes (which often require additional privileges) are mitigated. Even if an escape bug is hit, the process might end up with the privileges of the sandbox’s user (which we can keep limited).

Given Apple’s track record, any _publicly known_ sandbox escape on macOS 14 will likely be patched promptly via system updates[\[27\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=,updates%20as%20soon%20as%20possible). We should monitor Apple security bulletins (for macOS “Sequoia” updates, which is macOS 14 Sonoma’s codename)[\[29\]](https://support.apple.com/en-us/124149#:~:text=Support%20support.apple.com%20%20CVE,break%20out%20of%20its%20sandbox) and apply them.

**Conclusion:** It is **possible** to have no _known_ escapes in our sandbox at deployment time, but that’s largely dependent on Apple’s OS security. Our role is to maximize security by layering defenses. Combining the App Sandbox (or custom seatbelt) \+ SIP \+ ES monitors \+ separate user/VM creates multiple hurdles for an attacker. This way, even if one layer fails (say a sandbox policy loophole is exploited), another layer (like not running as root, or being inside a VM) will stop the attacker from reaching the host system. This defense-in-depth approach is strongly recommended, and indeed it’s implied by the requirement. We should assume that single-layer sandboxing might be bypassed by a skilled attacker (as history has shown), so layering is crucial – and macOS provides the pieces to do this.

## 11\. Prefer No Root Privileges at Runtime

**Goal:** The sandboxed agent and its supervisor should run without requiring root privileges during normal operation, to reduce risk. We should avoid designs that need the process to be UID 0 or have the user disable system security features.

**Feasibility:** **Possible.** macOS’s modern frameworks (Endpoint Security, Network Extension, Virtualization) are designed to work without running your process as root, provided you have the correct entitlements and user approvals. For example, an Endpoint Security extension runs as a System Extension under a special account (not root, but with authority granted by the ES subsystem). The Network Extension content filter also runs in user space with privileges bestowed by the NE framework once the user enables it. In both cases, the user (or an admin) must authorize the extension (via System Settings \> Privacy & Security), but they do not manually give you the root password or such – the system manages the privileges.

The one area where we might need transient root access is at installation or setup: e.g., to create a separate “sandbox” user account, one might invoke sysadminctl (as Alcoholless does) which requires admin rights[\[30\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=%24%20alclessctl%20create%20default%207%3A41PM,C%20to%20abort). But this is a one-time setup, not something the agent needs every time it runs. Running the actual agent as a less privileged user is the whole idea.

We will _not_ require the user to disable SIP or do any insecure root hacks. In fact, to use App Sandbox or system extensions, SIP must remain **enabled** (Apple generally refuses to work if SIP is off, ironically). We also wouldn’t want to run the agent with sudo—that would defeat a lot of the purpose. Instead, if the agent ever needs to perform something that normally requires root (say binding to a privileged port, or mounting a filesystem), we should handle that via the supervisor (which could be a launchd-launched daemon with only that specific privilege, or by using macOS’s Authorization Services to grant a one-time privilege, etc.).

**Example:** The Alcoholless sandbox tool explicitly chose not to extend the kernel or require persistent root; it uses existing userland mechanisms (creating users, using sudo only to switch user context, then dropping root)[\[9\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20just%20utilizes%201990s%E2%80%99%20commands,are%20not%20recognized%20by%20POSIX). That aligns with our goals. Also, the Virtualization framework can run a VM as a normal user (no root needed) once you have the entitlement – no need for sudo to launch a VM.

**Conclusion:** We definitely can and will design the sandbox so that neither the agent nor the supervisor runs as root full-time. The supervisor might run with elevated _capabilities_ via entitlements, but it’s still an ordinary user-space process subject to OS sandboxing (System Extensions are restricted themselves in what they can do – they just have the rights for their specific domain). This requirement is **fully possible**. It is consistent with best practices on macOS – Apple encourages developers to avoid requiring root and to use privilege separation. By using the official frameworks (ES, NE, etc.), we satisfy this: they require certain code signing permissions but not a root user. In summary, we can meet requirement \#11 by ensuring any necessary root actions (like initial setup or installing a privileged helper) are done upfront, and running the runtime sandbox and supervisor as non-root processes.

## 12\. Integration with Nix-like Safe Package Managers

**Goal:** The sandbox should play nicely with package managers that emphasize reproducibility and sandboxing (like Nix). This could mean allowing the agent to use a Nix store or similar, and leveraging their safety benefits (immutable package files, isolated build environments).

**Feasibility:** **Possible.** Nix on macOS itself uses sandboxing to isolate package builds – historically, Nix invoked /usr/bin/sandbox-exec with a strict profile to sandbox build processes. Recent versions use Apple’s libsandbox API directly[\[3\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=The%20fix%20for%20this%20issue,exec%60%20to%20%60libsandbox). So Nix and our sandbox share common mechanisms. If anything, we can harness Nix’s approach: for example, Nix’s sandbox profile typically disallows network and restricts filesystem access to only the Nix store and temporary build dirs[\[31\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=On%20macOS%2C%20built,paths%20in%20the%20Nix%20store). Our agent’s sandbox could be configured similarly, which might allow us to run Nix builds inside it without issue since Nix expects that environment.

Integration might involve: the sandboxed agent can call Nix to install certain dependencies. The Nix store (/nix/store) is usually world-readable but only modifiable by the Nix daemon (running as root). We can **whitelist** /nix/store as read-only in the sandbox so the agent can use packages from it. We should also whitelist whatever directories Nix uses for builds (usually /private/var/folders/.../Nix/... or something, or $TMPDIR during builds) but ensure those are contained.

If the agent tries to _build_ new packages via Nix, note that Nix will attempt to sandbox those builds itself. However, Nix’s sandbox on macOS is not enabled by default because it can break some builds and requires root privileges to manage build users[\[32\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=Note%20that%20sandboxing%20is%20not,a%20build%20has%20access%20to). If we want maximum safety, we could turn on Nix’s sandbox mode too – though that might be double sandboxing (running a sandbox inside our sandbox). It should still work, since Nix’s use of sandbox-exec (or libsandbox) would just further restrict the compiler processes. There is a caveat: Nix’s sandbox can’t completely isolate network on macOS beyond what seatbelt can do (and seatbelt can’t filter localhost as noted)[\[33\]](https://news.ycombinator.com/item?id=43796750#:~:text=Not%20trying%20to%20be%20condescending,derivations%20access%20to%20the). But since our environment already blocks network unless allowed, that is fine.

**Nix-style guarantees** (like content-addressed, read-only packages) complement our sandbox: for instance, we can rely on the fact that binaries in /nix/store are immutable and have cryptographic hashes in their names. We might trust those more and allow reading them. Also, a “Nix-like” package manager implies a declarative, sandboxed build process – which aligns with how we want to run any untrusted code (in isolation).

**Conclusion:** Integrating with Nix is **feasible**. We likely will **allow the sandbox to use Nix** by including the Nix store in the read allowlist. We can also use Nix’s sandbox as an extra layer: Nix’s sandboxed builds (when enabled) use the same macOS sandbox facilities, so they won’t conflict but just add more restrictions. The fact that Nix’s sandbox was not primarily for security (more for reproducibility) means it isn’t bulletproof, but combined with our policies it’s fine[\[32\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=Note%20that%20sandboxing%20is%20not,a%20build%20has%20access%20to). We should be mindful that Nix on macOS requires the daemon to run as root for certain tasks (like installing new packages globally). Perhaps the supervisor could coordinate those actions (since we prefer not to have the agent itself run sudo). But these are implementation details. In summary, using a Nix-like manager inside our sandbox is **possible** and even advantageous – both Nix and our sandbox can work together to limit filesystem and network access during package builds[\[31\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=On%20macOS%2C%20built,paths%20in%20the%20Nix%20store). We will just ensure our sandbox doesn’t inadvertently block Nix’s normal functioning (for example, allow access to the Nix database or daemon socket if needed, in a controlled way).

**Overall Conclusion:** All the listed requirements can be met **to varying degrees** on macOS 14 Sonoma. Some (like write restrictions, process isolation, no-root, supervisor-based control) are fully possible with Apple’s current technologies. Others (like dynamic prompts, fine-grained network rules, resource limits) require careful use of Apple’s Endpoint Security and Network Extension frameworks or creative workarounds. A combination of **Seatbelt sandbox profiles, App Sandbox entitlements, ES/NE system extensions, user privilege separation, and optionally the Virtualization framework** provides a comprehensive sandbox environment. This layered approach aligns with Apple’s security model and ensures that even if one layer has a weakness, others compensate – achieving a robust sandbox for the “agent-harbor” on macOS Sonoma.

**Sources:**

- Apple Developer Documentation on App Sandbox and sandbox profiles[\[4\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=The%20new%20approach%20is%20the,an%20app%20to%20do%20so)[\[34\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,write%2A%20%28regex%20%22%5E%2FUsers)

- Discussion of sandbox-exec deprecation and continued use on macOS[\[6\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=app%20startup,an%20app%20to%20do%20so)[\[5\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=While%20Apple%20claims%20this%20older,in%20various%20places%20such%20as)

- Endpoint Security framework capabilities (file and process blocking)[\[10\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,to%20how%20antivirus%20software%20works)[\[21\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,remount)

- Network filtering limitations of sandbox vs. need for firewall[\[18\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=The%20man%20page%20for%20%60sandbox,though%20is%20not%20good%20news)[\[19\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%3E%20host%20must%20be%20,or%20localhost%20in%20network%20address)

- Example sandbox profiles for file and network restrictions[\[2\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=To%20alleviate%20the%20risk%20of,exec%20%60command%20on%20macOS)[\[15\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,data%20%28regex%20%22%5E%2FUsers%2F%5B%5E%2F%5D%2B%2F%28Documents%7CPictures%7CDesktop)

- macOS Sonoma changes to sandbox container access (user prompts)[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing)[\[12\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=Sandbox%20containers%20on%20Sonoma%20seemed,apps%2C%20even%20from%20Terminal%20app)

- Nix sandbox usage on macOS (switch from sandbox-exec to libsandbox)[\[3\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=The%20fix%20for%20this%20issue,exec%60%20to%20%60libsandbox)

- Known sandbox escape vulnerability CVE-2025-31191 and patch[\[26\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=In%20April%202024%2C%20Microsoft%20uncovered,target%20the%20Microsoft%20Office%20app)[\[27\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=,updates%20as%20soon%20as%20possible)

- macOS resource limit behaviors (RLIMIT_AS not enforced)[\[23\]](https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit#:~:text=1)

- Virtualization entitlement requirement[\[24\]](https://developer.apple.com/documentation/virtualization/adding-the-virtualization-entitlement-to-your-project#:~:text=Adding%20the%20Virtualization%20Entitlement%20to,this%20entitlement%20to%20your%20app) and sandboxing tools like Alcoholless design[\[35\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20just%20utilizes%201990s%E2%80%99%20commands,are%20not%20recognized%20by%20POSIX)

---

[\[1\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=%60sandbox,with%20a%20profile%20like) [\[2\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=To%20alleviate%20the%20risk%20of,exec%20%60command%20on%20macOS) [\[8\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=How%20it%20works) [\[9\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20just%20utilizes%201990s%E2%80%99%20commands,are%20not%20recognized%20by%20POSIX) [\[25\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20could%20even%20harden%20security,iCloud%2C%20set%20up%20SSH%2C%20etc) [\[30\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=%24%20alclessctl%20create%20default%207%3A41PM,C%20to%20abort) [\[35\]](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301#:~:text=Alcoholless%20just%20utilizes%201990s%E2%80%99%20commands,are%20not%20recognized%20by%20POSIX) Alcoholless: A Lightweight Security Sandbox for macOS Programs (Homebrew, AI Agents, etc.) | by Akihiro Suda | nttlabs | Jul, 2025 | Medium

[https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301](https://medium.com/nttlabs/alcoholless-lightweight-security-sandbox-for-macos-ccf0d1927301)

[\[3\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=The%20fix%20for%20this%20issue,exec%60%20to%20%60libsandbox) [\[31\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=On%20macOS%2C%20built,paths%20in%20the%20Nix%20store) [\[32\]](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg#:~:text=Note%20that%20sandboxing%20is%20not,a%20build%20has%20access%20to) macOS sandbox escape via built-in builders · Advisory · NixOS/nix · GitHub

[https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg](https://github.com/NixOS/nix/security/advisories/GHSA-wf4c-57rh-9pjg)

[\[4\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=The%20new%20approach%20is%20the,an%20app%20to%20do%20so) [\[5\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=While%20Apple%20claims%20this%20older,in%20various%20places%20such%20as) [\[6\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=app%20startup,an%20app%20to%20do%20so) [\[7\]](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now#:~:text=As%20a%20user%2C%20sandboxing%20profiles,the%20newer%20App%20Sandbox%20feature) macos \- How to sandbox third party applications when \`sandbox-exec\` is deprecated now? \- Stack Overflow

[https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now](https://stackoverflow.com/questions/56703697/how-to-sandbox-third-party-applications-when-sandbox-exec-is-deprecated-now)

[\[10\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,to%20how%20antivirus%20software%20works) [\[13\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=execute%20from%20the%20Endpoint%20Security,to%20how%20antivirus%20software%20works) [\[21\]](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security#:~:text=,remount) Collect Telemetry Data on macOS with Apple’s Endpoint Security \- Apriorit

[https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security](https://www.apriorit.com/dev-blog/collecting-telemetry-data-on-macos-using-endpoint-security)

[\[11\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=,between%20an%20app%E2%80%99s%20code%20signing) [\[12\]](https://lapcatsoftware.com/articles/2023/6/1.html#:~:text=Sandbox%20containers%20on%20Sonoma%20seemed,apps%2C%20even%20from%20Terminal%20app) macOS Sonoma sandbox security

[https://lapcatsoftware.com/articles/2023/6/1.html](https://lapcatsoftware.com/articles/2023/6/1.html)

[\[14\]](https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html#:~:text=Attaching%20a%20debugger%20to%20the,is%20not%20enabled%20by%20default) Debugging on macOS — Godot Engine (4.4) documentation in English

[https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html](https://docs.godotengine.org/en/4.4/contributing/development/debugging/macos_debug.html)

[\[15\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,data%20%28regex%20%22%5E%2FUsers%2F%5B%5E%2F%5D%2B%2F%28Documents%7CPictures%7CDesktop) [\[34\]](https://igorstechnoclub.com/sandbox-exec/#:~:text=,write%2A%20%28regex%20%22%5E%2FUsers) sandbox-exec: macOS's Little-Known Command-Line Sandboxing Tool | Igor's Techno Club

[https://igorstechnoclub.com/sandbox-exec/](https://igorstechnoclub.com/sandbox-exec/)

[\[16\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%28allow%20default%29%20%28deny%20network,outbound%20%28remote%20ip%20%2210.0.1.1%3A443) [\[17\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%28deny%20network,outbound%20%28remote%20ip%20%2210.0.1.1%3A443) [\[18\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=The%20man%20page%20for%20%60sandbox,though%20is%20not%20good%20news) [\[19\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=%3E%20host%20must%20be%20,or%20localhost%20in%20network%20address) [\[20\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=more%20information%29) [\[22\]](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based#:~:text=Filtering%20network%20access%20to%20specific,normally%20blocked%2Fallowed%3F%20Not%20sure%20though) macos \- Native OS X sandbox profile to control network access (IP/host-based) \- Information Security Stack Exchange

[https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based](https://security.stackexchange.com/questions/133624/native-os-x-sandbox-profile-to-control-network-access-ip-host-based)

[\[23\]](https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit#:~:text=1) Python on MacOS totally ignoring rlimit \- Stack Overflow

[https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit](https://stackoverflow.com/questions/15633474/python-on-macos-totally-ignoring-rlimit)

[\[24\]](https://developer.apple.com/documentation/virtualization/adding-the-virtualization-entitlement-to-your-project#:~:text=Adding%20the%20Virtualization%20Entitlement%20to,this%20entitlement%20to%20your%20app) Adding the Virtualization Entitlement to Your Project \- Apple Developer

[https://developer.apple.com/documentation/virtualization/adding-the-virtualization-entitlement-to-your-project](https://developer.apple.com/documentation/virtualization/adding-the-virtualization-entitlement-to-your-project)

[\[26\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=In%20April%202024%2C%20Microsoft%20uncovered,target%20the%20Microsoft%20Office%20app) [\[27\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=,updates%20as%20soon%20as%20possible) [\[28\]](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/#:~:text=Since%202022%2C%20Apple%20has%20made,of%20malicious%20Office%20macros%20is) Analyzing CVE-2025-31191: A macOS security-scoped bookmarks-based sandbox escape | Microsoft Security Blog

[https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/](https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/)

[\[29\]](https://support.apple.com/en-us/124149#:~:text=Support%20support.apple.com%20%20CVE,break%20out%20of%20its%20sandbox) About the security content of macOS Sequoia 15.6 \- Apple Support

[https://support.apple.com/en-us/124149](https://support.apple.com/en-us/124149)

[\[33\]](https://news.ycombinator.com/item?id=43796750#:~:text=Not%20trying%20to%20be%20condescending,derivations%20access%20to%20the) Not trying to be condescending but simply put the sandbox-exec ...

[https://news.ycombinator.com/item?id=43796750](https://news.ycombinator.com/item?id=43796750)

## Appendix - Extra Q&A

Q: Can I configure a seatbelt sandbox in a way that programs like `killall` kill only processes started inside the sandbox?

Short answer: you can get _close_ with a seatbelt (SBPL) profile, but you can't express "only processes that were _started inside the same sandbox_." Seatbelt's `signal` rule only knows three targets: _self_, _same process-group_, and _others_. There's no filter for "same sandbox profile." ([Reverse Engineering][1])

## What you _can_ do

Run the tools you want to control (including `killall`) and the processes they’re allowed to kill in the **same process group**, then write an SBPL profile that only permits sending signals to `self` and `same-group`, denying everything else.

Example (minimal) profile:

```scheme
(version 1)
(deny default)

;; allow making your cohort
(allow process-fork)
(allow process-exec)              ; if you need to exec helpers

;; only let us send signals to ourselves or our PGID
(allow signal (target self))
(allow signal (target same-group))
(deny  signal (target others))    ; <- blocks killing anything outside the cohort

;; optional hardening: limit process enumeration, so tools don’t see the world
(deny process-info*)              ; default deny process info
(allow process-info-pidinfo (target self))
(allow process-info-setcontrol (target self))
```

* The `signal` semantics (including `target self | same-group | others`) are documented in Apple's "Apple Sandbox Guide" (reversed from seatbelt), with examples of denying signals to "others." ([Reverse Engineering][1])
* macOS profiles commonly restrict _process-info_ operations (e.g., `process-info-listpids`), and you can selectively re-allow for `self` as WebKit's own profile does. This keeps a sandboxed `ps`/`killall` from listing global PIDs freely.

### How to use it

Launch your cohort in a new session/PGID (e.g., from a small launcher that calls `setsid()` or `setpgid()`), then run `killall` _under the same profile_. `killall` will still _try_ to find processes by name, but signals to processes outside the PGID will fail due to the `signal (target others)` deny. ([Reverse Engineering][1])

## When that isn’t enough

If you truly need "only processes that belong to _my_ isolated set," Seatbelt alone can't label membership that way. The robust route is an _Endpoint Security_ (ES) client that authorizes signal events (`ES_EVENT_TYPE_AUTH_SIGNAL`) and denies any signal unless both sender and target match your criteria (e.g., ancestry, audit token, code signature, or a runtime tag). ES lets you gate each `kill(2)` regardless of the caller, which cleanly enforces "inside → inside only." ([Apple Developer][3])

## Caveats

* `sandbox-exec`/SBPL are not first-class public APIs (Apple treats them as internal/deprecated), but they remain widely used (Chromium, Nix) and current profiles still work on modern macOS. Test on the exact OS you target. ([zameermanji.com][4])
* Some tools bypass libc wrappers; denial happens at the kernel policy layer, but for best UX you may also want to hide global PIDs via the `process-info*` denies so commands don’t “see” things they can’t signal. ([Apple Developer][5])

If you want, I can sketch a tiny launcher + profile that creates the process group and runs your workload + a sandboxed `killall` so it only succeeds against that cohort.

[1]: https://reverse.put.as/wp-content/uploads/2011/09/Apple-Sandbox-Guide-v1.0.pdf?utm_source=chatgpt.com "Apple Sandbox Guide v1.0 - Reverse Engineering"
[3]: https://docs.developer.apple.com/documentation/endpointsecurity/es_event_type_auth_signal?utm_source=chatgpt.com "ES_EVENT_TYPE_AUTH_SIGNAL | Apple Developer Documentation"
[4]: https://zameermanji.com/blog/2025/4/1/sandboxing-subprocesses-in-python-on-macos/?utm_source=chatgpt.com "Sandboxing subprocesses in Python on macOS - Zameer Manji"
[5]: https://developer.apple.com/forums/thread/661372?utm_source=chatgpt.com "Sandbox violation for process-info… | Apple Developer Forums"
