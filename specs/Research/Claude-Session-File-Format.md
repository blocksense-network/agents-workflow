# Claude Session File Format Specification

## Overview

Claude Code stores session data in a comprehensive JSONL (JSON Lines) format that captures the complete conversation history, tool usage, and metadata for coding sessions. Unlike the simpler Codex format, Claude's session files include rich context about the development environment, detailed tool interactions, and sophisticated conversation threading.

## File Location and Naming

```
~/.claude/projects/<encoded-project-path>/<session-uuid>.jsonl
```

- Project paths are encoded by replacing `/` with `-` (e.g., `/Users/zahary/project` becomes `-Users-zahary-project`)
- Each session gets a unique UUID-based filename
- Files are stored in project-specific subdirectories for organization

## File Structure

Each line in a Claude session file is a JSON object representing a single conversation event:

```json
{
  "parentUuid": "c3be33fc-f78a-44e9-8a59-505d86d17429",
  "isSidechain": false,
  "userType": "external",
  "cwd": "/Users/zahary/blocksense/agent-harbor",
  "sessionId": "8f9e1698-672b-40ee-af6d-ec906d4910c0",
  "version": "1.0.98",
  "gitBranch": "main",
  "type": "user",
  "message": { ... },
  "uuid": "c3be33fc-f78a-44e9-8a59-505d86d17429",
  "timestamp": "2025-09-22T08:13:25.951Z"
}
```

## Root Object Structure

### Core Fields

All session entries share these common fields:

```typescript
interface SessionEntry {
  parentUuid: string | null;     // UUID of parent message (conversation threading)
  isSidechain: boolean;          // Whether this is part of a side conversation
  userType: "external";          // Type of user (always "external" for human users)
  cwd: string;                   // Current working directory
  sessionId: string;             // Session UUID
  version: string;               // Claude Code version
  gitBranch: string;             // Current git branch
  type: "user" | "assistant";    // Message type
  uuid: string;                  // Unique identifier for this entry
  timestamp: string;             // ISO 8601 timestamp with milliseconds
  message?: MessageContent;      // Message content (for conversation entries)
  
  // Optional fields for specific entry types
  isMeta?: boolean;              // Metadata entries
  isApiErrorMessage?: boolean;   // API error indicators
  toolUseResult?: ToolResult;    // Tool execution results
  requestId?: string;            // API request correlation ID
}
```

## Message Types

### 1. User Messages

User messages represent input from the human user:

```json
{
  "type": "user",
  "message": {
    "role": "user",
    "content": "Take a look at the python project in tests/tool/mock-agent..."
  },
  "parentUuid": null,
  "isSidechain": false
}
```

**User Message Variants:**

#### Standard Text Message

```json
{
  "message": {
    "role": "user",
    "content": "Please help me debug this code"
  }
}
```

#### Tool Result Message

```json
{
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01XWHgxtdr8TznBdnvwJRzHB",
        "type": "tool_result",
        "content": "File written successfully",
        "is_error": false
      }
    ]
  },
  "toolUseResult": {
    "stdout": "tests/tools/mock-agent\ntests/tools/mock-agent/src/agent.py",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
```

#### Command Output Messages

```json
{
  "message": {
    "role": "user",
    "content": "<command-name>/login</command-name>\n<command-message>login</command-message>\n<command-args></command-args>"
  }
}
```

#### Metadata Messages

```json
{
  "isMeta": true,
  "message": {
    "role": "user",
    "content": "Caveat: The messages below were generated by the user while running local commands..."
  }
}
```

### 2. Assistant Messages

Assistant messages contain Claude's responses, including tool usage:

```json
{
  "type": "assistant",
  "message": {
    "id": "msg_01KFSq5UvQMn6eKgrSP4kupk",
    "type": "message",
    "role": "assistant",
    "model": "claude-sonnet-4-20250514",
    "content": [
      {
        "type": "text",
        "text": "I'll help you examine the Python project..."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": { ... }
  },
  "requestId": "req_011CTP7owyFrEeGSPcXfQXFE"
}
```

#### Assistant Text Response

```json
{
  "message": {
    "content": [
      {
        "type": "text",
        "text": "I'll help you analyze this code..."
      }
    ]
  }
}
```

#### Assistant Tool Use

```json
{
  "message": {
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01XWHgxtdr8TznBdnvwJRzHB",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Explore the project structure",
              "status": "in_progress",
              "activeForm": "Exploring the project structure"
            }
          ]
        }
      }
    ]
  }
}
```

#### API Error Messages

```json
{
  "type": "assistant",
  "isApiErrorMessage": true,
  "message": {
    "content": [
      {
        "type": "text",
        "text": "Credit balance is too low"
      }
    ]
  }
}
```

## Usage Statistics

Assistant messages include detailed token usage and performance metrics:

```json
{
  "usage": {
    "input_tokens": 6,
    "cache_creation_input_tokens": 531,
    "cache_read_input_tokens": 15896,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 531,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 73,
    "service_tier": "standard"
  }
}
```

### Usage Fields

- `input_tokens`: New tokens sent to the model
- `cache_creation_input_tokens`: Tokens used to create cache entries
- `cache_read_input_tokens`: Tokens read from cache
- `output_tokens`: Tokens generated by the model
- `service_tier`: API service level ("standard", etc.)
- `cache_creation`: Breakdown by cache duration (5 minutes, 1 hour)

## Tool Results

Tool execution results are stored in both the message content and a separate `toolUseResult` field:

### File Operation Results

```json
{
  "toolUseResult": {
    "type": "text",
    "file": {
      "filePath": "/Users/zahary/project/file.py",
      "content": "print('Hello, World!')\n",
      "numLines": 1,
      "startLine": 1,
      "totalLines": 1
    }
  }
}
```

### Command Execution Results

```json
{
  "toolUseResult": {
    "stdout": "total 8\ndrwxr-xr-x 7 staff 224 Sep 22 10:55 .",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
```

### Todo Management Results

```json
{
  "toolUseResult": {
    "oldTodos": [],
    "newTodos": [
      {
        "content": "Explore the project structure",
        "status": "in_progress",
        "activeForm": "Exploring the project structure"
      }
    ]
  }
}
```

### Error Results

```json
{
  "toolUseResult": "Error: File does not exist."
}
```

## Conversation Threading

Claude sessions use a sophisticated threading model to track conversation flow:

### Parent-Child Relationships

- `parentUuid`: Points to the UUID of the previous message in the conversation
- `null` parentUuid indicates the start of a conversation thread
- Forms a linked list of conversation messages

### Sidechain Conversations

- `isSidechain`: Boolean indicating parallel conversation threads
- Allows for handling interruptions and context switches
- Maintains conversation coherence across complex interactions

## Git Integration

Each entry captures git repository state:

```json
{
  "gitBranch": "main",
  "cwd": "/Users/zahary/blocksense/agent-harbor"
}
```

This enables:

- Context-aware suggestions based on current branch
- Change tracking across sessions
- Repository-specific conversation history

## Environment Context

### Working Directory Tracking

- `cwd`: Current working directory for each message
- Enables path resolution and context-aware file operations
- Supports multi-project workflows

### Version Information

- `version`: Claude Code version (e.g., "1.0.98")
- `sessionId`: Unique session identifier
- Enables compatibility handling and feature tracking

## Tools and Extensions

Claude sessions capture rich tool interaction data:

### Supported Tool Types

- **File Operations**: Read, Write, Edit, Glob, Grep
- **Command Execution**: Bash commands with full I/O capture
- **Task Management**: TodoWrite for progress tracking
- **Web Operations**: WebFetch, WebSearch
- **IDE Integration**: Diagnostics, code execution
- **Version Control**: Git operations and status

### Tool Call Format

```json
{
  "type": "tool_use",
  "id": "toolu_01N2d64oohHGa5H4BWFrPAam",
  "name": "Bash",
  "input": {
    "command": "find tests -type d -name \"*mock*\"",
    "description": "Find directories with mock in the name"
  }
}
```

### Tool Result Format

Tool results are captured with full context including success/failure status, output data, and metadata for debugging and replay.

## Security and Privacy

### Sensitive Data Handling

- File paths may reveal project structure
- Command outputs may contain sensitive information
- Tool results capture full execution context
- Consider data classification for enterprise deployments

### File Permissions

- Session files should use restrictive permissions (0o600)
- Located in user's home directory (`~/.claude/`)
- Project isolation through directory structure

## Performance Characteristics

### Storage Efficiency

- JSONL format for streamable processing
- Incremental session building
- Efficient for large conversation histories
- Compressed representations where appropriate

### Memory Usage

- Append-only writes for reliability
- Lazy loading of session history
- Bounded memory usage for active sessions

## Usage Examples

### Analyzing Session Files

```bash
# Pretty print session with jq
jq -C . ~/.claude/projects/-Users-zahary-project/session-uuid.jsonl

# Extract all user messages
jq 'select(.type == "user") | .message.content' session.jsonl

# Find tool usage
jq 'select(.type == "assistant" and .message.content[]?.type == "tool_use")' session.jsonl

# Extract performance metrics
jq '.message.usage // empty' session.jsonl
```

### Session Statistics

```bash
# Count messages by type
jq -r '.type' session.jsonl | sort | uniq -c

# Track token usage over time
jq '.message.usage.output_tokens // 0' session.jsonl | awk '{sum += $1} END {print sum}'

# Find longest conversations
find ~/.claude/projects -name "*.jsonl" -exec wc -l {} \; | sort -nr
```

### Programmatic Access

```typescript
// Load session history
interface SessionEntry { /* ... */ }
const session: SessionEntry[] = readSessionFile(path);

// Extract conversation messages
const conversation = session
  .filter(entry => entry.message && !entry.isMeta)
  .map(entry => ({
    role: entry.type,
    content: entry.message.content,
    timestamp: entry.timestamp
  }));

// Analyze tool usage
const toolCalls = session
  .filter(entry => entry.message?.content?.some(c => c.type === "tool_use"))
  .map(entry => /* extract tool data */);
```

## Comparison with Codex Format

### Key Differences

| Aspect             | Codex Format               | Claude Format                                |
| ------------------ | -------------------------- | -------------------------------------------- |
| **Threading**      | Simple linear sequence     | Rich parent-child relationships              |
| **Context**        | Basic session metadata     | Full environment context (git, cwd, version) |
| **Tool Data**      | Function call/result pairs | Rich tool execution context                  |
| **Performance**    | Token counts only          | Detailed usage and caching metrics           |
| **Organization**   | Date-based directories     | Project-based organization                   |
| **Error Handling** | Basic error recording      | Comprehensive error context                  |

### Migration Considerations

- Claude format is more complex but provides richer context
- Codex sessions can be imported with some data loss
- Tool result formats are incompatible and require translation
- Claude's threading model enables more sophisticated conversation analysis

## Claude Code Multi-System Coordination

Claude Code sessions demonstrate sophisticated multi-system coordination where several subsystems work together during active development sessions:

### Coordinated File Systems

During active Claude Code sessions, multiple file systems update in coordination:

1. **Primary Session Recording**
   - Main session file (`session-uuid.jsonl`) grows continuously during conversation
   - New conversation entries append in real-time as tool calls and results are recorded
   - File size increases by ~40KB during typical 60-minute sessions

2. **Todo Management Synchronization**
   - Todo files created when TodoWrite tool is used: `session-uuid-agent-session-uuid.json`
   - Files transition from populated arrays to empty arrays `[]` as tasks complete
   - Real-time task state tracking enables progress visibility throughout session

3. **Analytics Coordination**
   - Statsig session tracking runs parallel to conversation recording
   - Uses separate session ID (e.g., `3063c6db-394a-48cb-bb2c-a888ad0eb6cf`) from conversation ID
   - File timestamps update every few seconds indicating active session monitoring
   - Multiple analytics files coordinate: session tracking, cached evaluations, modification timestamps

4. **Environment Context Capture**
   - Shell snapshots created at session start: `snapshot-zsh-timestamp-id.sh`
   - Captures shell aliases, environment variables, PATH configuration
   - Enables proper tool execution in user's customized development environment

5. **Plugin System Integration**
   - Repository tracking configuration: `~/.claude/plugins/config.json`
   - Initialized as `{"repositories": {}}` for new repositories
   - Provides foundation for future repository-specific customizations

### Cross-System ID Management

The session format uses sophisticated ID coordination across subsystems:

- **Conversation ID**: Used for session recording and todo tracking (shared identifier)
- **Analytics Session ID**: Separate identifier for usage analytics and feature tracking
- **Shell Snapshot ID**: Timestamp-based identifier for environment capture
- **Tool Use IDs**: Unique identifiers for each tool call within the session

### Evidence of Real-Time Coordination

Analysis of active sessions reveals:

- Session files grow continuously during conversation (not batch-written)
- Todo files empty as tasks complete, demonstrating real-time state synchronization
- Analytics files update every few seconds during active use
- Environment context captured at session initialization for consistent tool execution
- Multiple subsystems coordinate through shared session identifiers

This multi-system coordination enables Claude Code to provide comprehensive development support while maintaining detailed audit trails and sophisticated session management capabilities.

## Environment Snapshot Analysis

Claude Code captures comprehensive environment context at session startup through shell snapshot files. These snapshots preserve the user's complete development environment to enable seamless tool execution.

### Shell Snapshot File Format

Environment snapshots (`snapshot-zsh-timestamp-id.sh`) are executable shell scripts that recreate the user's development environment. The file structure follows this format:

```bash
# Snapshot file
# Unset all aliases to avoid conflicts with functions
unalias -a 2>/dev/null || true

# Functions
function_name() {
    # User-defined function body
}

# Shell Options
setopt option_name
setopt another_option

# Aliases
alias -- short_name=full_command
alias -- another_alias='command with args'

# Tool availability checks
if ! command -v tool_name >/dev/null 2>&1; then
  alias tool_name='/path/to/fallback/tool'
fi

# PATH export (single line)
export PATH=/path1:/path2:/path3:...:/pathN
```

### Content Categories Captured

#### 1. Shell Functions

- User-defined functions for development workflows
- Infrastructure management and deployment scripts
- Build system integrations and automation tools
- Git workflow helpers and version control operations
- System administration and utility functions

#### 2. Shell Configuration

- Shell options (`setopt`) for enhanced behavior
- Command aliases for frequently used tools
- Conditional aliases providing fallbacks for missing tools
- Environment variable exports

#### 3. Development PATH

- Complete PATH environment variable preserving:
  - Package manager tool paths (Nix, Homebrew, etc.)
  - Language runtime and toolchain paths
  - Development utility locations
  - System and user-specific binary directories
  - AI coding assistant executables

#### 4. Tool Integration

- Fallback mechanisms for missing development tools
- Environment compatibility across different systems
- Integration with package managers and development environments

### Environment Preservation Benefits

This comprehensive environment capture enables:

1. **Reproducible tool execution**: Commands execute with the user's exact environment
2. **Context-aware operations**: Understanding available tools and workflows
3. **Cross-session consistency**: Maintaining environment state across sessions
4. **Development workflow integration**: Leveraging established practices
5. **Tool compatibility**: Handling missing or alternative tool installations

### Security and Privacy Considerations

Environment snapshots may contain sensitive information:

- Infrastructure hostnames and connection details
- Authentication method configurations
- Personal development practices and workflows
- Project-specific build and deployment configurations
- File system paths revealing project structures

The snapshot format demonstrates Claude Code's sophisticated approach to environment preservation, ensuring seamless integration with existing development workflows while maintaining the user's customized shell environment.

## File Format Evolution

### Version Compatibility

- `version` field enables format evolution tracking
- New tool types can be added without breaking parsers
- Unknown fields are preserved for forward compatibility
- Breaking changes require careful migration planning

### Future Extensions

- Enhanced tool result schemas
- Additional context fields
- Improved compression and storage efficiency
- Real-time collaboration support
